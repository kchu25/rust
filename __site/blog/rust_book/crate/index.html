<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'BPdots';
      src: url('/blockchains/assets/fonts/BPdots/BPdots.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'BPdots';
      src: url('/blockchains/assets/fonts/BPdots/BPdotsBold.otf') format('opentype');
      font-weight: bold;
      font-style: normal;
    }
  </style>
  
   <link rel="stylesheet" href="/libs/highlight/styles/atom-one-dark.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/hypertext.css">
<link rel="icon" href="/assets/favicon.png">

   <title>Rust Packages and Crates: Untangled</title>  
</head>
<body>
<header>
  <h1 style="color:#283747; font-family:'BPdots', monospace; font-size:2.5em; font-weight:normal; letter-spacing:0.1em">rust</h1>
  <nav>
    <a href="/" class="current">Tags</a>
  | <a href="/blog/" >Notes</a>
  <hr/>
  </nav>
</header>


<!-- Content appended here -->
<div class="franklin-content"><h1 id="rust_packages_and_crates_untangled"><a href="#rust_packages_and_crates_untangled" class="header-anchor">Rust Packages and Crates: Untangled</a></h1>
<p>The official Rust book introduces three concepts at once—crates, packages, and modules—which can feel overwhelming. Let&#39;s untangle them one layer at a time.</p>
<hr />
<h2 id="the_big_picture"><a href="#the_big_picture" class="header-anchor">The Big Picture</a></h2>
<pre><code class="language-julia">Package &#40;has Cargo.toml&#41;
├── Crate &#40;binary&#41; ← compiled to executable
├── Crate &#40;library&#41; ← compiled to shareable code
└── Crate &#40;binary&#41; ← you can have multiple binaries</code></pre>
<p>Think of it like this:</p>
<ul>
<li><p><strong>Crate</strong> &#61; a unit of compilation &#40;what <code>rustc</code> compiles&#41;</p>
</li>
<li><p><strong>Package</strong> &#61; a bundle of crates managed by Cargo &#40;has <code>Cargo.toml</code>&#41;</p>
</li>
<li><p><strong>Module</strong> &#61; organization within a crate &#40;we&#39;ll cover this separately&#41;</p>
</li>
</ul>
<hr />
<h2 id="what_is_a_crate"><a href="#what_is_a_crate" class="header-anchor">What is a Crate?</a></h2>
<p>A <strong>crate</strong> is the smallest unit of code the Rust compiler deals with. When you run <code>rustc</code> on a file, that file is a crate.</p>
<h3 id="two_kinds_of_crates"><a href="#two_kinds_of_crates" class="header-anchor">Two Kinds of Crates</a></h3>
<table><tr><th align="right">Type</th><th align="right">Has <code>main</code>?</th><th align="right">Compiles to</th><th align="right">Example</th></tr><tr><td align="right"><strong>Binary crate</strong></td><td align="right">Yes</td><td align="right">Executable you can run</td><td align="right">CLI tool, server, game</td></tr><tr><td align="right"><strong>Library crate</strong></td><td align="right">No</td><td align="right">Code others can use</td><td align="right"><code>rand</code>, <code>serde</code>, <code>tokio</code></td></tr></table>
<pre><code class="language-rust">// Binary crate - has main&#40;&#41;, runs as a program
fn main&#40;&#41; &#123;
    println&#33;&#40;&quot;I&#39;m an executable&#33;&quot;&#41;;
&#125;

// Library crate - no main&#40;&#41;, provides functionality
pub fn useful_function&#40;&#41; &#123;
    // Other code can call this
&#125;</code></pre>
<blockquote>
<p><strong>What does <code>pub</code> mean?</strong></p>
<p>The <code>pub</code> keyword means <strong>public</strong>. By default, everything in Rust is <em>private</em>—only accessible within the same module. Adding <code>pub</code> makes an item visible to code outside its module.</p>
</blockquote>
<pre><code class="language-rust">&gt; fn private_function&#40;&#41; &#123; &#125;      // Only usable within this module
&gt; pub fn public_function&#40;&#41; &#123; &#125;   // Usable by external code
&gt;</code></pre>
<blockquote>
<p>For a library crate, you <em>must</em> mark functions as <code>pub</code> if you want other code to use them. Without <code>pub</code>, your library would be useless—nothing would be accessible&#33;</p>
</blockquote>
<blockquote>
<p><strong>How <code>pub</code> relates to <code>use</code></strong></p>
<p>The <code>use</code> keyword brings items into scope so you don&#39;t have to write full paths. But you can only <code>use</code> items that are <strong>public</strong> &#40;<code>pub</code>&#41; to you:</p>
</blockquote>
<pre><code class="language-rust">&gt; // In some library crate &quot;mylib&quot;
&gt; pub fn public_fn&#40;&#41; &#123; &#125;     // ✓ Can be imported
&gt; fn private_fn&#40;&#41; &#123; &#125;        // ✗ Cannot be imported from outside
&gt;
&gt; pub mod utils &#123;            // Module is public
&gt;     pub fn helper&#40;&#41; &#123; &#125;    // ✓ Can be imported
&gt;     fn secret&#40;&#41; &#123; &#125;        // ✗ Cannot be imported from outside
&gt; &#125;
&gt;</code></pre>
<blockquote>
</blockquote>
<pre><code class="language-rust">&gt; // In your code
&gt; use mylib::public_fn;           // ✓ Works
&gt; use mylib::private_fn;          // ✗ Error: private
&gt; use mylib::utils::helper;       // ✓ Works &#40;both mod and fn are pub&#41;
&gt; use mylib::utils::secret;       // ✗ Error: private
&gt;</code></pre>
<blockquote>
<p>The <code>::</code> in paths like <code>mylib::utils::helper</code> is just navigating through modules—like folders in a file path. Each segment must be <code>pub</code> for external code to reach through it.</p>
</blockquote>
<blockquote>
<p><strong>What can <code>use</code> import?</strong></p>
<p><code>use</code> can import almost anything—not just functions:</p>
</blockquote>
<pre><code class="language-rust">&gt; use std::collections::HashMap;  // struct
&gt; use std::io::Result;            // type alias
&gt; use std::cmp::Ordering;         // enum
&gt; use std::fmt::Debug;            // trait
&gt; use std::f64::consts::PI;       // constant
&gt; use mylib::utils;               // module itself
&gt; use mylib::utils::helper;       // function
&gt;</code></pre>
<blockquote>
<p>When you import a <strong>module</strong>, you can then access its contents with <code>::</code>:</p>
</blockquote>
<pre><code class="language-rust">&gt; use std::collections;           // import the module
&gt; let map &#61; collections::HashMap::new&#40;&#41;;  // use items inside it
&gt;</code></pre>
<blockquote>
<p>When you import a <strong>specific item</strong>, you use it directly:</p>
</blockquote>
<pre><code class="language-rust">&gt; use std::collections::HashMap;  // import the struct directly
&gt; let map &#61; HashMap::new&#40;&#41;;       // no prefix needed
&gt;</code></pre>
<blockquote>
<p><strong>TL;DR:</strong> <code>use</code> controls how much of the namespace path you want visible. You&#39;re choosing where to &quot;stop&quot; in the path hierarchy.</p>
</blockquote>
<blockquote>
<p><strong>&quot;Crate&quot; usually means library</strong></p>
<p>When Rustaceans say &quot;I&#39;m using the <code>serde</code> crate,&quot; they mean library crate. It&#39;s interchangeable with &quot;library&quot; in casual conversation.</p>
</blockquote>
<h3 id="the_crate_root"><a href="#the_crate_root" class="header-anchor">The Crate Root</a></h3>
<p>Every crate has a <strong>root file</strong>—the starting point for compilation:</p>
<table><tr><th align="right">Crate type</th><th align="right">Root file</th></tr><tr><td align="right">Binary</td><td align="right"><code>src/main.rs</code></td></tr><tr><td align="right">Library</td><td align="right"><code>src/lib.rs</code></td></tr></table>
<p>The compiler starts at the root and follows all the <code>mod</code> declarations to find the rest of your code.</p>
<blockquote>
<p><strong>What does <code>mod</code> mean?</strong></p>
<p>The <code>mod</code> keyword declares a <strong>module</strong>—a way to organize code into separate namespaces. When the compiler sees <code>mod foo;</code>, it looks for the code in either:</p>
<ul>
<li><p><code>foo.rs</code> &#40;a file&#41;, or</p>
</li>
<li><p><code>foo/mod.rs</code> &#40;a folder with a mod.rs file&#41;</p>
</li>
</ul>
</blockquote>
<pre><code class="language-rust">&gt; // In src/lib.rs or src/main.rs
&gt; mod utils;    // Tells compiler: &quot;look for utils.rs or utils/mod.rs&quot;
&gt; mod helpers;  // Tells compiler: &quot;look for helpers.rs or helpers/mod.rs&quot;
&gt;</code></pre>
<blockquote>
<p>Think of <code>mod</code> as creating a tree structure. The crate root is the trunk, and each <code>mod</code> declaration adds a branch. We&#39;ll cover modules in detail in a separate post.</p>
</blockquote>
<hr />
<h2 id="what_is_a_package"><a href="#what_is_a_package" class="header-anchor">What is a Package?</a></h2>
<p>A <strong>package</strong> is what you create when you run <code>cargo new</code>. It&#39;s a directory with:</p>
<ul>
<li><p>A <code>Cargo.toml</code> file &#40;the manifest&#41;</p>
</li>
<li><p>One or more crates</p>
</li>
</ul>
<blockquote>
<p><strong>What&#39;s a manifest?</strong></p>
<p>A <strong>manifest</strong> is a file that describes your project&#39;s metadata and configuration. In Rust, it&#39;s <code>Cargo.toml</code>. It tells Cargo:</p>
<ul>
<li><p>What your package is called</p>
</li>
<li><p>What version it is</p>
</li>
<li><p>What dependencies it needs</p>
</li>
<li><p>How to build it</p>
</li>
</ul>
<p>Think of it like a shipping label &#43; packing list for your code. The name comes from shipping terminology—a ship&#39;s manifest lists everything on board.</p>
</blockquote>
<pre><code class="language-bash">&#36; cargo new my-project
     Created binary &#40;application&#41; &#96;my-project&#96; package

&#36; tree my-project
my-project
├── Cargo.toml    ← Package manifest
└── src
    └── main.rs   ← Binary crate root</code></pre>
<h3 id="package_rules"><a href="#package_rules" class="header-anchor">Package Rules</a></h3>
<ol>
<li><p><strong>At least one crate</strong> &#40;binary or library&#41;</p>
</li>
<li><p><strong>At most one library crate</strong> &#40;you can only have one <code>src/lib.rs</code>&#41;</p>
</li>
<li><p><strong>Any number of binary crates</strong> &#40;multiple executables are fine&#41;</p>
</li>
</ol>
<hr />
<h2 id="package_configurations"><a href="#package_configurations" class="header-anchor">Package Configurations</a></h2>
<h3 id="binary_only_most_common_for_applications"><a href="#binary_only_most_common_for_applications" class="header-anchor">Binary Only &#40;most common for applications&#41;</a></h3>
<pre><code class="language-julia">my-app/
├── Cargo.toml
└── src/
    └── main.rs      ← Binary crate &quot;my-app&quot;</code></pre>
<p>This is what <code>cargo new my-app</code> creates.</p>
<h3 id="library_only_for_sharing_code"><a href="#library_only_for_sharing_code" class="header-anchor">Library Only &#40;for sharing code&#41;</a></h3>
<pre><code class="language-julia">my-lib/
├── Cargo.toml
└── src/
    └── lib.rs       ← Library crate &quot;my-lib&quot;</code></pre>
<p>This is what <code>cargo new my-lib --lib</code> creates.</p>
<h3 id="both_binary_and_library"><a href="#both_binary_and_library" class="header-anchor">Both Binary and Library</a></h3>
<pre><code class="language-julia">my-project/
├── Cargo.toml
└── src/
    ├── main.rs      ← Binary crate &quot;my-project&quot;
    └── lib.rs       ← Library crate &quot;my-project&quot;</code></pre>
<p>The binary can use the library:</p>
<pre><code class="language-rust">// src/main.rs
use my_project::useful_function;  // Import from the library crate

fn main&#40;&#41; &#123;
    useful_function&#40;&#41;;
&#125;</code></pre>
<pre><code class="language-rust">// src/lib.rs
pub fn useful_function&#40;&#41; &#123;
    println&#33;&#40;&quot;Called from the library&#33;&quot;&#41;;
&#125;</code></pre>
<h3 id="multiple_binaries"><a href="#multiple_binaries" class="header-anchor">Multiple Binaries</a></h3>
<pre><code class="language-julia">my-project/
├── Cargo.toml
└── src/
    ├── main.rs          ← Binary &quot;my-project&quot;
    ├── lib.rs           ← Library &quot;my-project&quot;
    └── bin/
        ├── tool1.rs     ← Binary &quot;tool1&quot;
        └── tool2.rs     ← Binary &quot;tool2&quot;</code></pre>
<p>Run them with:</p>
<pre><code class="language-bash">cargo run --bin my-project
cargo run --bin tool1
cargo run --bin tool2</code></pre>
<hr />
<h2 id="convention_over_configuration"><a href="#convention_over_configuration" class="header-anchor">Convention Over Configuration</a></h2>
<p>Cargo uses <strong>file location</strong> to determine crate structure. You don&#39;t need to specify these in <code>Cargo.toml</code>:</p>
<table><tr><th align="right">File exists</th><th align="right">Cargo assumes</th></tr><tr><td align="right"><code>src/main.rs</code></td><td align="right">Binary crate with package name</td></tr><tr><td align="right"><code>src/lib.rs</code></td><td align="right">Library crate with package name</td></tr><tr><td align="right"><code>src/bin/foo.rs</code></td><td align="right">Additional binary crate named &quot;foo&quot;</td></tr></table>
<p>This is why <code>Cargo.toml</code> often has no explicit crate configuration—Cargo just looks at your file structure.</p>
<hr />
<h2 id="why_separate_binary_and_library"><a href="#why_separate_binary_and_library" class="header-anchor">Why Separate Binary and Library?</a></h2>
<p>A common pattern: put your logic in a library crate, and keep <code>main.rs</code> thin.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li><p>Library can be tested independently</p>
</li>
<li><p>Library can be used by other projects</p>
</li>
<li><p>Binary is just a thin wrapper that calls library functions</p>
</li>
</ul>
<pre><code class="language-rust">// src/lib.rs - All the real logic
pub fn run_app&#40;args: Vec&lt;String&gt;&#41; -&gt; Result&lt;&#40;&#41;, String&gt; &#123;
    // Complex logic here
    Ok&#40;&#40;&#41;&#41;
&#125;

// src/main.rs - Just the entry point
fn main&#40;&#41; &#123;
    let args: Vec&lt;String&gt; &#61; std::env::args&#40;&#41;.collect&#40;&#41;;
    if let Err&#40;e&#41; &#61; my_project::run_app&#40;args&#41; &#123;
        eprintln&#33;&#40;&quot;Error: &#123;&#125;&quot;, e&#41;;
        std::process::exit&#40;1&#41;;
    &#125;
&#125;</code></pre>
<hr />
<h2 id="quick_reference"><a href="#quick_reference" class="header-anchor">Quick Reference</a></h2>
<table><tr><th align="right">Term</th><th align="right">What it is</th><th align="right">Example</th></tr><tr><td align="right"><strong>Crate</strong></td><td align="right">Compilation unit</td><td align="right"><code>rand</code>, your <code>main.rs</code></td></tr><tr><td align="right"><strong>Binary crate</strong></td><td align="right">Compiles to executable</td><td align="right">CLI app, server</td></tr><tr><td align="right"><strong>Library crate</strong></td><td align="right">Compiles to reusable code</td><td align="right"><code>serde</code>, <code>tokio</code></td></tr><tr><td align="right"><strong>Crate root</strong></td><td align="right">Entry point for compiler</td><td align="right"><code>src/main.rs</code>, <code>src/lib.rs</code></td></tr><tr><td align="right"><strong>Package</strong></td><td align="right">Bundle of crates &#43; <code>Cargo.toml</code></td><td align="right">What <code>cargo new</code> creates</td></tr></table>
<hr />
<h2 id="mental_model"><a href="#mental_model" class="header-anchor">Mental Model</a></h2>
<pre><code class="language-julia">┌─────────────────────────────────────────┐
│  Package &#40;Cargo.toml&#41;                   │
│  &quot;A project managed by Cargo&quot;           │
│                                         │
│  ┌──────────────┐  ┌──────────────┐    │
│  │ Binary Crate │  │ Library Crate│    │
│  │ &#40;main.rs&#41;    │  │ &#40;lib.rs&#41;     │    │
│  │              │  │              │    │
│  │ → Executable │  │ → .rlib file │    │
│  └──────────────┘  └──────────────┘    │
│                                         │
│  ┌──────────────┐  ┌──────────────┐    │
│  │ Binary Crate │  │ Binary Crate │    │
│  │ &#40;bin/a.rs&#41;   │  │ &#40;bin/b.rs&#41;   │    │
│  └──────────────┘  └──────────────┘    │
└─────────────────────────────────────────┘</code></pre>
<p><strong>Next up:</strong> Modules—how to organize code <em>within</em> a crate.</p>
<div class="page-foot">
    Contact me by <a href="mailto:skchu@wustl.edu">E-mail</a> | <a href="https://github.com/kchu25">Github</a> | <a href="https://www.linkedin.com/in/kchu1/">Linkedin</a>
    <br>
    This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.  Last modified: January 30, 2026.
    <br>
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>
// Register Solidity language for highlight.js
hljs.registerLanguage('solidity', function(hljs) {
  return {
    keywords: {
      keyword: 'contract interface library pragma import using struct enum event modifier function returns return require revert assert emit new delete if else for while do break continue try catch throw this super constructor fallback receive ' +
                'public private internal external pure view payable virtual override constant immutable anonymous indexed storage memory calldata',
      literal: 'true false wei gwei ether seconds minutes hours days weeks years',
      built_in: 'msg block tx abi now sender value gas data origin gasprice blockhash gasleft address uint int bytes string bool mapping'
    },
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.QUOTE_STRING_MODE,
      hljs.APOS_STRING_MODE,
      {
        className: 'number',
        begin: '\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)',
        relevance: 0
      },
      {
        className: 'type',
        begin: '\\b(uint|int|bytes|byte|string|address|bool|ufixed|fixed)(\\d+x\\d+|\\d+)?\\b'
      },
      {
        className: 'function',
        beginKeywords: 'function modifier event constructor fallback receive',
        end: '[{;]',
        excludeEnd: true,
        contains: [
          {
            className: 'title',
            begin: '[A-Za-z$_][0-9A-Za-z$_]*',
            relevance: 0
          },
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE]
          }
        ]
      }
    ]
  };
});

hljs.highlightAll();
hljs.configure({tabReplace: '    '});
</script>


    
  </body>
</html>
